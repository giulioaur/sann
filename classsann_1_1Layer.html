<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SANN: Sushi Artificial Neural Network: sann::Layer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SANN: Sushi Artificial Neural Network
   </div>
   <div id="projectbrief">This is a short library for a simple but efficient neural network</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sann</b></li><li class="navelem"><a class="el" href="classsann_1_1Layer.html">Layer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsann_1_1Layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sann::Layer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a layer of the neural network.  
 <a href="classsann_1_1Layer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Layer_8hpp_source.html">Layer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa2c0f9abe2859c56dda02ae56ea127fd"><td class="memItemLeft" align="right" valign="top"><a id="aa2c0f9abe2859c56dda02ae56ea127fd"></a>
typedef std::function&lt; weightsMatrix(const std::size_t m, const std::size_t n)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weights_initializer</b></td></tr>
<tr class="separator:aa2c0f9abe2859c56dda02ae56ea127fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9638da93e267990828784b4d4ef95aeb"><td class="memItemLeft" align="right" valign="top"><a id="a9638da93e267990828784b4d4ef95aeb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a9638da93e267990828784b4d4ef95aeb">Layer</a> ()</td></tr>
<tr class="memdesc:a9638da93e267990828784b4d4ef95aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty layer. <br /></td></tr>
<tr class="separator:a9638da93e267990828784b4d4ef95aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2a1b71a6c05d9a1348522d1a52cfd"><td class="memItemLeft" align="right" valign="top"><a id="af3d2a1b71a6c05d9a1348522d1a52cfd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Layer</b> (std::size_t numOfNeurons, const <a class="el" href="classsann_1_1math_1_1Func.html">math::Func</a> &amp;activationFunc, const short level=-1)</td></tr>
<tr class="separator:af3d2a1b71a6c05d9a1348522d1a52cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae229fe55d3a51c3d816a1f86e9e311ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#ae229fe55d3a51c3d816a1f86e9e311ad">Layer</a> (const <a class="el" href="classsann_1_1Layer.html">Layer</a> &amp;lay)</td></tr>
<tr class="memdesc:ae229fe55d3a51c3d816a1f86e9e311ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new layer with the same number and type of perceptron of the existent one.  <a href="#ae229fe55d3a51c3d816a1f86e9e311ad">More...</a><br /></td></tr>
<tr class="separator:ae229fe55d3a51c3d816a1f86e9e311ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee73ab4c87760259236a418811ae008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#aeee73ab4c87760259236a418811ae008">setWeights</a> (const std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="memdesc:aeee73ab4c87760259236a418811ae008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weight of the layer.  <a href="#aeee73ab4c87760259236a418811ae008">More...</a><br /></td></tr>
<tr class="separator:aeee73ab4c87760259236a418811ae008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d2a30bc9ee9bebb682bf091201cb1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#aa1d2a30bc9ee9bebb682bf091201cb1b">setWeights</a> (const weightsMatrix &amp;weights)</td></tr>
<tr class="memdesc:aa1d2a30bc9ee9bebb682bf091201cb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weights of the layer.  <a href="#aa1d2a30bc9ee9bebb682bf091201cb1b">More...</a><br /></td></tr>
<tr class="separator:aa1d2a30bc9ee9bebb682bf091201cb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2355082c8c55ce49f2c2f234d7d8fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a6c2355082c8c55ce49f2c2f234d7d8fb">setWeights</a> (weightsMatrix &amp;&amp;weights)</td></tr>
<tr class="memdesc:a6c2355082c8c55ce49f2c2f234d7d8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the new weights of the layer using move semantics.  <a href="#a6c2355082c8c55ce49f2c2f234d7d8fb">More...</a><br /></td></tr>
<tr class="separator:a6c2355082c8c55ce49f2c2f234d7d8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de081e634189ad9a8900554605f8bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a5de081e634189ad9a8900554605f8bf6">setWeights</a> (const weights_initializer &amp;init, const size_t n)</td></tr>
<tr class="memdesc:a5de081e634189ad9a8900554605f8bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weights matrix using a user-defined function.  <a href="#a5de081e634189ad9a8900554605f8bf6">More...</a><br /></td></tr>
<tr class="separator:a5de081e634189ad9a8900554605f8bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a48e18da734f5e508b92ec4e95eca8b"><td class="memItemLeft" align="right" valign="top">const weightsMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a6a48e18da734f5e508b92ec4e95eca8b">getWeights</a> () const</td></tr>
<tr class="memdesc:a6a48e18da734f5e508b92ec4e95eca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the layer.  <a href="#a6a48e18da734f5e508b92ec4e95eca8b">More...</a><br /></td></tr>
<tr class="separator:a6a48e18da734f5e508b92ec4e95eca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6027f5a48d48b08e71366a77d3333db4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a6027f5a48d48b08e71366a77d3333db4">getSize</a> () const</td></tr>
<tr class="memdesc:a6027f5a48d48b08e71366a77d3333db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of neurons.  <a href="#a6027f5a48d48b08e71366a77d3333db4">More...</a><br /></td></tr>
<tr class="separator:a6027f5a48d48b08e71366a77d3333db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3506d24f2a70c413201f9b335cc754"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a7d3506d24f2a70c413201f9b335cc754">feed_forward</a> (const std::vector&lt; double &gt; &amp;inputs)</td></tr>
<tr class="memdesc:a7d3506d24f2a70c413201f9b335cc754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vector of outputs of the current layer. When this method is call, the result of the net function is stored inside the object to do not recompute it later during back propagation. So be careful in introducing network parallelization (for small net is not even necessary since -O3 optimization flag is sufficient).  <a href="#a7d3506d24f2a70c413201f9b335cc754">More...</a><br /></td></tr>
<tr class="separator:a7d3506d24f2a70c413201f9b335cc754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a91ebdb59bf9b9ebe8e870d552ce85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a86a91ebdb59bf9b9ebe8e870d552ce85">back_propagation</a> (const std::vector&lt; double &gt; &amp;inputs, const std::vector&lt; double &gt; &amp;errors)</td></tr>
<tr class="memdesc:a86a91ebdb59bf9b9ebe8e870d552ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the algorithm of back propagation on the current layer. It's important noting that to avoid compute the error on this layer once this function would be called on previous layer, the error is computed in the current call and then passed as argument to the previous layer.  <a href="#a86a91ebdb59bf9b9ebe8e870d552ce85">More...</a><br /></td></tr>
<tr class="separator:a86a91ebdb59bf9b9ebe8e870d552ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d1f3d0b8593eb6b4b64c58c3dde1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsann_1_1Layer.html#a953d1f3d0b8593eb6b4b64c58c3dde1b">updateWeights</a> (const <a class="el" href="structsann_1_1p.html">sann::parameters</a> &amp;hyperP)</td></tr>
<tr class="memdesc:a953d1f3d0b8593eb6b4b64c58c3dde1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the weigths of the current layer. Use the hyperparameters to compute how much the weight will change.  <a href="#a953d1f3d0b8593eb6b4b64c58c3dde1b">More...</a><br /></td></tr>
<tr class="separator:a953d1f3d0b8593eb6b4b64c58c3dde1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a layer of the neural network. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae229fe55d3a51c3d816a1f86e9e311ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae229fe55d3a51c3d816a1f86e9e311ad">&#9670;&nbsp;</a></span>Layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sann::Layer::Layer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsann_1_1Layer.html">Layer</a> &amp;&#160;</td>
          <td class="paramname"><em>lay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new layer with the same number and type of perceptron of the existent one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lay</td><td>- The existent layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a86a91ebdb59bf9b9ebe8e870d552ce85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a91ebdb59bf9b9ebe8e870d552ce85">&#9670;&nbsp;</a></span>back_propagation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; sann::Layer::back_propagation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the algorithm of back propagation on the current layer. It's important noting that to avoid compute the error on this layer once this function would be called on previous layer, the error is computed in the current call and then passed as argument to the previous layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>- The inputs of previous layer. </td></tr>
    <tr><td class="paramname">errors</td><td>- The errors of the next layer. On the output layer9 this is the vector of the output errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; - The vector of errors to propagate back to previous layer. </dd></dl>

</div>
</div>
<a id="a7d3506d24f2a70c413201f9b335cc754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3506d24f2a70c413201f9b335cc754">&#9670;&nbsp;</a></span>feed_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; sann::Layer::feed_forward </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vector of outputs of the current layer. When this method is call, the result of the net function is stored inside the object to do not recompute it later during back propagation. So be careful in introducing network parallelization (for small net is not even necessary since -O3 optimization flag is sufficient). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>- The inputs from the previous layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; - The vector of outputs of the current layer. </dd></dl>

</div>
</div>
<a id="a6027f5a48d48b08e71366a77d3333db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6027f5a48d48b08e71366a77d3333db4">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t sann::Layer::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of neurons. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t - The number of neurons </dd></dl>

</div>
</div>
<a id="a6a48e18da734f5e508b92ec4e95eca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a48e18da734f5e508b92ec4e95eca8b">&#9670;&nbsp;</a></span>getWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const weightsMatrix &amp; sann::Layer::getWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the layer. </p>
<dl class="section return"><dt>Returns</dt><dd>weightsMatrix - The weights. </dd></dl>

</div>
</div>
<a id="aeee73ab4c87760259236a418811ae008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee73ab4c87760259236a418811ae008">&#9670;&nbsp;</a></span>setWeights() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sann::Layer::setWeights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weight of the layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>- The weights to which init the neurons. The size should be equal to #neuron_prev_layer * #neuron_curr_layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d2a30bc9ee9bebb682bf091201cb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d2a30bc9ee9bebb682bf091201cb1b">&#9670;&nbsp;</a></span>setWeights() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sann::Layer::setWeights </td>
          <td>(</td>
          <td class="paramtype">const weightsMatrix &amp;&#160;</td>
          <td class="paramname"><em>weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weights of the layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>- The new weights. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c2355082c8c55ce49f2c2f234d7d8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2355082c8c55ce49f2c2f234d7d8fb">&#9670;&nbsp;</a></span>setWeights() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sann::Layer::setWeights </td>
          <td>(</td>
          <td class="paramtype">weightsMatrix &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the new weights of the layer using move semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>- The new weights. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5de081e634189ad9a8900554605f8bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de081e634189ad9a8900554605f8bf6">&#9670;&nbsp;</a></span>setWeights() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sann::Layer::setWeights </td>
          <td>(</td>
          <td class="paramtype">const weights_initializer &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weights matrix using a user-defined function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>- The function that generates a random weights matrix m x n. </td></tr>
    <tr><td class="paramname">n</td><td>- The number of neurons of the previous layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953d1f3d0b8593eb6b4b64c58c3dde1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953d1f3d0b8593eb6b4b64c58c3dde1b">&#9670;&nbsp;</a></span>updateWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sann::Layer::updateWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsann_1_1p.html">sann::parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>hyperP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the weigths of the current layer. Use the hyperparameters to compute how much the weight will change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hyperP</td><td>- The hyperparameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sann/<a class="el" href="Layer_8hpp_source.html">Layer.hpp</a></li>
<li>sann/Layer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
